

let minMaxMap = {},
  numLinksDict = {},
  links_not_filtered,
  nodes_not_filtered,
  nodes,
  node_ids,
  links,
  currentLabHighlightList,
  currentYear = "All",
  maxStrength,
  labs,
  simulation,
  svg,
  link, 
  node,
  defs,
  pieG,
  minNumConnections = 20,
  g, gl,
  referenceCache,
  currentTopic = "All",
  mapMin = 1,   // Start of the output range
  mapMax = 60,
  startDegree = -135,   // Start of the dial in degrees
  endDegree = 135,   // End of the dial in degrees
  startPos = -48,
  currentDialDeg = startPos,
  numText,
  dialGroup,
  mousePos,
  linearGradient,
  gl_,
  linearGradientDict = {},
  Tooltip,
  transformation,
  svgPoint,
  boundingRect,
  mouseIsDragging = false,
  body,
   tooltipFlippedX = false, // Track whether tooltip is flipped horizontally
 tooltipFlippedY = false,
 mouseIsOver = false,
 objectBeingDragged; // Track whether tooltip is flipped vertically; 

 // mapping dictionary generated by ChatGPT 4.0
LABS_CONTINENT = {
    "vigyanashram":"Asia", // India
    "oulu":"Europe", // Finland
    "kamplintfort":"Europe", // Germany
    "charlotte":"North America", // USA (Assumed)
    "lccc":"North America", // USA (Assumed)
    "bahrain":"Asia", // Bahrain
    "uae":"Asia", // United Arab Emirates
    "libya":"Africa", // Libya
    "techworks":"North America", // USA (Assumed)
    "newcairo":"Africa", // Egypt
    "egypt":"Africa", // Egypt
    "lakazlab":"Africa", // Mauritius (Assumed)
    "tecsup":"South America", // Peru
    "wheaton":"North America", // USA (Assumed)
    "fablabuae":"Asia", // United Arab Emirates
    "qbic":"Asia", // Qatar (Assumed)
    "kochi":"Asia", // India
    "ied":"Europe", // Italy (Assumed)
    "fablabtrivandrum":"Asia", // India
    "fablabakgec":"Asia", // India
    "barcelona":"Europe", // Spain
    "fablabsorbonne":"Europe", // France
    "fablabcept":"Asia", // India
    "rwanda":"Africa", // Rwanda
    "leon":"Europe", // Spain (Assumed)
    "lamachinerie":"Europe", // France (Assumed)
    "fablabdigiscope":"Europe", // France (Assumed)
    "energylab":"Europe", // Denmark (Assumed)
    "akgec":"Asia", // India
    "irbid":"Asia", // Jordan
    "reykjavik":"Europe", // Iceland
    "sorbonne":"Europe", // France
    "incitefocus":"North America", // USA (Assumed)
    "puebla":"North America", // Mexico
    "tecsupaqp":"South America", // Peru
    "ucontinental":"South America", // Peru
    "fablabopendot":"Europe", // Italy
    "santachiara":"Europe", // Italy
    "fablabechofab":"North America", // Canada
    "zoi":"Asia", // China (Assumed)
    "cidi":"North America", // USA (Assumed)
    "dassault":"Europe", // France (Assumed)
    "stjude":"North America", // USA (Assumed)
    "aalto":"Europe", // Finland
    "fablabzoi":"Asia", // China (Assumed)
    "ecae":"Asia", // United Arab Emirates
    "fablabbahrain":"Asia", // Bahrain
    "khairpur":"Asia", // Pakistan
    "insper":"South America", // Brazil
    "trivandrum":"Asia", // India
    "inphb":"Africa", // Ivory Coast
    "digiscope":"Europe", // France (Assumed)
    "ulb":"Europe", // Belgium (Assumed)
    "lima":"South America", // Peru
    "fablabspinderihallerne":"Europe", // Denmark
    "fablabfct":"Europe", // Portugal (Assumed)
    "fct":"Africa", // Nigeria (Assumed)
    "opendot":"Europe", // Italy
    "fablabtecsup":"South America", // Peru
    "vancouver":"North America", // Canada
    "fablabbrighton":"Europe", // UK
    "akureyri":"Europe", // Iceland
    "yucatan":"North America", // Mexico
    "bhutan":"Asia", // Bhutan
    "fablabaachen":"Europe", // Germany
    "waag":"Europe", // Netherlands
    "echofab":"North America", // Canada
    "dilijan":"Asia", // Armenia
    "polytech":"Europe", // France (Assumed)
    "agrilab":"Asia", // Armenia
    "fablabsiena":"Europe", // Italy -- ChatGPT changed "fablabsiena" to "siena" -- corrected by hand
    "winam":"Africa", // Kenya (Assumed)
    "fablaboulu":"Europe", // Finland
    "fablabreykjavik":"Europe", // Iceland
    "kamakura":"Asia", // Japan
    "falabvestmannaeyjar":"Europe", // Iceland
    "singapore":"Asia", // Singapore
    "oshanghai":"Asia", // China
    "fablaboshanghai":"Asia", // China
    "fablabutec":"South America", // Peru
    "fablabodessa":"Europe", // Ukraine
    "esan":"South America", // Peru
    "fablabvigyanasharm":"Asia", // India
    "hkispace":"Asia", // Hong Kong
    "taipei":"Asia", // Taiwan
    "fablabmexico":"North America", // Mexico
    "ciudadmexico":"North America", // Mexico
    "aachen":"Europe", // Germany
    "fablabbottrop":"Europe", // Germany
    "fablabaalto":"Europe", // Finland
    "keolab":"Asia", // Japan (Assumed)
    "cpcc":"North America", // USA (Assumed)
    "fablabkamplintfort":"Europe", // Germany
    "ingegno":"Europe", // Italy (Assumed)
    "fablabkamakura":"Asia", // Japan
    "tinkerers":"Asia", // United Arab Emirates (Assumed)
    "cit":"Europe", // Ireland (Assumed)
    "utec":"South America", // Peru
    "fablabamsterdam":"Europe", // Netherlands
    "tianhelab":"Asia", // China (Assumed)
    "bhubaneswar":"Asia", // India
    "cept":"Asia", // India
    "fablabbeijing":"Asia", // China
    "talents":"Europe", // Germany (Assumed)
    "fablabyachay":"South America", // Ecuador
    "fablabdassault":"Europe", // France (Assumed)
    "ecostudio":"North America", // USA (Assumed)
    "fablabseoul":"Asia", // South Korea
    "kaust":"Asia", // Saudi Arabia
    "berytech":"Asia", // Lebanon
    "fablabpuebla":"North America", // Mexico
    "fablabrwanda":"Africa", // Rwanda
    "fablabesan":"South America", // Peru
    "fablabberytech":"Asia", // Lebanon
    "crunchlab":"Europe", // Portugal (Assumed)
    "ucal":"North America", // USA (Assumed)
    "vestmannaeyjar":"Europe", // Iceland
    "sedi":"Europe", // Italy (Assumed)
    "isafjordur":"Europe", // Iceland
    "fablabegypt":"Africa", // Egypt
    "szoil":"Asia", // China
    "formshop":"Asia", // China (Assumed)
    "fablabkochi":"Asia", // India
    "fablabincitefocus":"North America", // USA (Assumed)
    "kitakagaya":"Asia", // Japan
    "kannai":"Asia", // Japan
    "dhahran":"Asia", // Saudi Arabia
    "seoulinnovation":"Asia", // South Korea
    "ioannina":"Europe", // Greece
    "fablabyucatan":"North America", // Mexico
    "fablabirbid":"Asia", // Jordan
    "deusto":"Europe", // Spain
    "falabdeusto":"Europe", // Spain
    "riidl":"Asia", // India
    "bottrop":"Europe", // Germany
    "fablabisafjorour":"Europe", // Iceland
    "plusx":"Asia", // South Korea (Assumed)
    "fablaberfindergarden":"Europe", // Germany (Assumed)
    "uemadrid":"Europe", // Spain
    "fablabtembisa":"Africa", // South Africa
    "brighton":"Europe", // UK
    "fablabfacens":"South America", // Brazil
    "fablableon":"Europe", // Spain (Assumed)
    "fablabszoil":"Asia", // China
    "fablabgearbox":"Africa", // Kenya (Assumed)
    "farmlabalgarve":"Europe", // Portugal
    "algarve":"Europe", // Portugal
    "twarda":"Europe", // Poland (Assumed)
    "bangalore":"Asia", // India
    "fablabsantiago":"South America", // Chile
    "fablablccc":"North America", // USA (Assumed)
    "fablabcharlottelatin":"North America", // USA
    "fablabat3flo":"Europe", // Hungary (Assumed)
    "fablabecostudio":"North America", // USA (Assumed)
    "fablabsocom":"Asia", // China (Assumed)
    "boldseoul":"Asia", // South Korea
    "napoli":"Europe", // Italy
    "fablabkromlaboro":"Europe", // Slovenia (Assumed)
    "seoul":"Asia", // South Korea
    "fablabtechworks":"North America", // USA (Assumed)
    "fablabkhairpur":"Asia", // Pakistan
    "chaihuo":"Asia", // China (Assumed)
    "fablabulb":"Europe", // Belgium (Assumed)
    "esne":"Europe", // Spain (Assumed)
    "ulima":"South America", // Peru
    "fablabseoulinnovation":"Asia", // South Korea
    "benfica":"Europe", // Portugal (Assumed)
    "fablabmadridceu":"Europe", // Spain
    "chandigarh":"Asia", // India
    "jubail":"Asia", // Saudi Arabia
    "ningbo":"Asia", // China
    "fablabwgtn":"Oceania", // New Zealand
};

const updateCallbacks = [
    (data, absl) => {
        const f = (nodes_not_filtered, links_not_filtered, filterFunc) => { // from filterStudents       
            let nodes = nodes_not_filtered.filter(n => filterFunc(n));

            let node_ids = nodes.map(n => n.id);
            let links = JSON.parse(JSON.stringify(links_not_filtered)).filter(l => { // DEEPCOPY SOLVES HEISENBUG!
              return (l.topic == absl.topic || absl.topic == "All") && (node_ids.includes(l.target)) && (node_ids.includes(l.source));
            });
            
            return [nodes, links];
        };
        const [nodes, links] = f(data.nodes, data.links, n => {
            if (absl.topic == "All") {
                return sumObj(numLinksDict[n.id].target) >= absl.minNumConnections;
            }
            else {
                return numLinksDict[n.id].target[absl.topic] >= absl.minNumConnections;
            }
        });
        return {nodes, links};
    } // code from transfernot_filtered...
];

const calculationCallbacks = [
    (data, absl) => {
        let maxStrength = 0;
        data.links.forEach(l => {
            if (l.value > maxStrength) {
            maxStrength = l.value;
            }
        });
        return {maxStrength};
    }, // code from calculateMaxStrength
    (data, absl) => {
      return {"condensedLinks": condenseLinksforSimulation(data.links)}
    },
    (data, absl, calcs) => {

        //gl.selectAll("path").remove(); // exit() isn't working and wouldn't unless I saved sel across calls, and that caused the not deleting circles error again
        //console.log(calcs.condensedLinks);
        const sel = absl.gl.selectAll("path").data(calcs.condensedLinks, l=>uniqueId(l));
    
        sel.exit()
            .remove();

        const ent = sel.enter().append("path").merge(sel);

        return {"link": ent};
    }, // code from linksToLink
    (data, absl) => {//from configureNode
        
        /*const toRemove = absl.g.selectAll("circle");
        console.log(toRemove);
        toRemove.remove();
        console.log(data.nodes);*/
        const sel = absl.g.selectAll("circle").data(data.nodes, n=>n.id);
        //if (data.nodes.length != 0 && data.nodes.length != 84) throw("error");
        sel.exit()
            .remove();
    
        const ent = sel.enter().append("circle").merge(sel);

        //absl.g.selectAll("circle").data(data.nodes, n=>n.id).enter().append("circle");

        return {"node": /*absl.g.selectAll("circle")*/ent};
    }
];

const attributeCallbacks = [
    (data, calcs, absl) => { // from selectByTopic
        calcs.node.attr("r", d => 
        {
          //console.log(d, referenceCache[d.id]);
          return referenceCache[d.id][absl.topic];
        });
        absl.simulation.nodes(data.nodes);
        forceCollide.initialize(data.nodes);
    },
    (data, calcs, absl) => {
        absl.simulation.force("link", d3.forceLink(calcs.condensedLinks).id(d => d.id).distance(d => getSimulationForceLinkDistance(d)));
        absl.simulation.force("collision", forceCollide.radius(d => d.r));
    },
    (data, calcs, absl) => {//also from configureNode
        //calcs.node.attr("r", d => referenceCache[d.id]["All"]);
        
        calcs.node.attr("fill", d => {
                const lab = d.id.split(";")[1].split("/")[5]; 
                return colorRegion(LABS_CONTINENT[lab]);
            })
            .attr("opacity", NODE_HIGHLIGHTED_OPACITY)
            .call(d3.drag()
            .on("start", dragstarted)
            .on("drag", dragged)
            .on("end", dragended));
    },
    (data, calcs, absl) => {//also from linksToLink
        calcs.link.attr("fill", "none") //ADDED
            .attr("stroke-width", LINE_WIDTH)
            .style("stroke-linecap", "round");
    },
    (data, calcs, absl) => {
        const linkTick = () => {
            calcs.link.attr("d", d => {
                const gradientID = getGradientID(d);
                const lg = document.getElementById(gradientID);
                const {source,
                  sourceYear,
                  sourceLab,
                  target,
                  targetYear,
                  targetLab} = getLinkSummary(d);
                const sourceIsActivated = activationCheck(absl.year, absl.currentLabHighlightList, sourceYear, sourceLab);
                const targetIsActivated = activationCheck(absl.year, absl.currentLabHighlightList, targetYear, targetLab);
                if (!((sourceIsActivated && targetIsActivated) || (!(sourceIsActivated || targetIsActivated)))) { // if only one is activated
                    
                    if (sourceIsActivated) {
                        //console.log(gradientID);
                    lg.setAttribute("x1", d.source.x);
                    lg.setAttribute("y1", d.source.y);
                    lg.setAttribute("x2", d.target.x);
                    lg.setAttribute("y2", d.target.y);
                  }
                  else {
                    lg.setAttribute("x2", d.source.x);
                    lg.setAttribute("y2", d.source.y);
                    lg.setAttribute("x1", d.target.x);
                    lg.setAttribute("y1", d.target.y);
                  }
                }
                const path = d3.path();
                path.moveTo(d.source.x, d.source.y);
                path.lineTo(d.target.x, d.target.y);
                return path.toString(); 
              });
        }
        linkTick();
        absl.simulation.on("tick", () => {
            linkTick();
            calcs.node
                .attr("cx", d => d.x)
                .attr("cy", d => d.y)
        });
    },
    (d, calcs, absl) => { // code from setYear
        calcs.node.attr("opacity", data => {
            const y = data.id.split(";")[1].split("/")[3];
            const lab = data.id.split(";")[1].split("/")[5];
            if ((y == absl.year || absl.year == "All") && absl.currentLabHighlightList.includes(lab)) {
              return NODE_HIGHLIGHTED_OPACITY;
            }
            else {
              return minOpacity;
            }
          });
    },
    (d, calcs, absl) => {// code from setLinkOpacity
        calcs.link.attr("opacity", data => {
            const {source,
              sourceYear,
              sourceLab,
              target,
              targetYear,
              targetLab} = getLinkSummary(data);
            let sourceIsOn = false;
            let targetIsOn = false;
        
            if (activationCheck(absl.year, absl.currentLabHighlightList, sourceYear, sourceLab)) {
              sourceIsOn = true;
            } 
            if (activationCheck(targetYear, targetLab)) {
              targetIsOn = true;
            }
        
            if ((sourceIsOn || targetIsOn) && !(sourceIsOn && targetIsOn)) {
              return null;
              /*if (sourceIsOn) {
                return "url(#LineFadeForward)";
              }
              return "url(#LineFadeBackward)";*/
            }
            return 1;
          });
          calcs.link.attr("stroke", data => { // SHOULD USE LINKS FROM SIMULATION BC OF CONDENSING?
            const source = data.source.id;
            const sourceYear = source.split(";")[1].split("/")[3];
            const sourceLab = source.split(";")[1].split("/")[5];
            const target = data.target.id;
            const targetYear = target.split(";")[1].split("/")[3];
            const targetLab = target.split(";")[1].split("/")[5];
            let sourceIsOn = false;
            let targetIsOn = false;
            
            if (activationCheck(absl.year, absl.currentLabHighlightList, sourceYear, sourceLab)) {
              sourceIsOn = true;
            } 
            if (activationCheck(absl.year, absl.currentLabHighlightList, targetYear, targetLab)) {
              targetIsOn = true;
            }
        
            if (sourceIsOn && targetIsOn) {
              return "rgba(" + RGB_LINE_COLOR + ",1)"; // this used to have opacity being set !!
            }
            else if (sourceIsOn || targetIsOn) {
              return `url(#${getGradientID(data)})`;
            }
            else {
              return "rgba(" + RGB_LINE_COLOR + ",0.05)";
            }
          });
    },
    (data, calcs, absl) => { // from setNodeTooltips
        
        calcs.node.each(function(e,i) {
            /*if (d3.select(this).selectAll("title").size() == 0) {d3.select(this).append("title").text(d => {
                return d.id.split(";")[0];
                });
            }
            //console.log(e,i);
            r = calcs.node.on('click', (d, i) => { window.open(i.id.split(";")[1], "_blank") });*/
            const currentNode = d3.select(this);
            if (!currentNode.on("mouseover")) {
              currentNode.on("mouseover", tooltipMouseover)
                .on("mousemove", tooltipMousemove)
                .on("mouseleave", tooltipMouseleave);
              currentNode.on('click', (d, i) => { window.open(i.id.split(";")[1], "_blank") })
            }
        });
    
        /*let r = calcs.node.append("title")
            .text(d => {
            return d.id.split(";")[0];
            });*/
            
        
    },
    (data, calcs, absl) => absl.simulation.alpha(1).restart()
];


const filterData = (funcs, absolutes) => {
    let d = {"nodes": nodes_not_filtered,
                "links": links_not_filtered};
    for (let f of funcs) {
        d = f(d, absolutes);
    }
    return d;
};

const runCalculations = (funcs, data, absolutes) => {
    let calcs = {};
    for (let f of funcs) {
        calcs = {...calcs, ...f(data, absolutes, calcs)};
    }
    return calcs;
}

const setDataAttributes = (funcs, data, calcs, absolutes) => {
    for (let f of funcs) {
        f(data, calcs, absolutes);
    }
}

const updateData = absolutes => {
    absolutes = {...absolutes, "topic": ("topic" in absolutes ? absolutes.topic : currentTopic), "year": currentYear, currentLabHighlightList};
    //console.log(JSON.stringify(absolutes));
    //console.log("updateData called with parameters: ", absolutes);
    const data = filterData(updateCallbacks, absolutes);
    //console.log(data);
    const calculationDict = runCalculations(calculationCallbacks, data, absolutes);
    setDataAttributes(attributeCallbacks, data, calculationDict, absolutes);
}

const clamp = (num, min, max) => Math.min(Math.max(num, min), max);

const toTitleCase = str => {
  return str.replace(
    /\w\S*/g,
    function (txt) {
      return txt.charAt(0).toUpperCase() + txt.substr(1).toLowerCase();
    }
  );
};

function normalize(value, min, max) {
  return (value - min) / (max - min);
}

const calculateMinMax = (ns, ls, topic) => {
    let minV = Infinity;
    let maxV = -Infinity;
    ns.forEach(n => {
      let v = 0;
      ls.forEach(l => {
        if (l.target == n.id && (topic == l.topic || topic == "All")) {
          v += l.value;//1;
        }
      });
      if (v < minV) minV = v;
      if (v > maxV) maxV = v;
    });
    //console.log("TOPIC", topic, minV, maxV);
    return {min: minV, max: maxV};
  };

  const sumObj = obj => Object.values(obj).reduce((a, b) => a + b, 0);

  const getAllLabs = node_ids => {
    let labs = [];
    for (let i = 0; i < node_ids.length; i++) {
      const node_id = node_ids[i];
      const lab = node_id.split(";")[1].split("/")[5];
      if (!labs.includes(lab)) labs.push(lab);
    }
    
    return labs;
  };
  
  const filterStudents = (nodes_not_filtered, links_not_filtered, filterFunc) => {
    let nodes = nodes_not_filtered.filter(n => filterFunc(n));
  
    let node_ids = nodes.map(n => n.id);

    let links = JSON.parse(JSON.stringify(links_not_filtered)).filter(l => { // DEEPCOPY SOLVES HEISENBUG!
      //if (l.source == "Árni Björnsson;https://fabacademy.org/2022/labs/isafjordur/students/arni-bjornsson/") debugger;
      return ((node_ids.includes(l.target.id)||node_ids.includes(l.target)) && (node_ids.includes(l.source.id)|node_ids.includes(l.source)));
    });
    //debugger;
    return [nodes, node_ids, links];
  };
  
  const uniqueId = l => {
    let sT;
    let tT;
    if (typeof l.source == 'string') {sT = l.source; tT = l.target;}
    else {sT = l.source.id; tT = l.target.id;}

    return `${sT}${tT}${l.topic}${l.value}`;
  };

  const createNumLinksDictFrom_not_filtered = () => {
    for (let i = 0; i < nodes_not_filtered.length; i++) {
      let toAdd = {"source": {}, "target": {}};
      for (let j = 0; j < TOPICS.length; j++) {
        toAdd.source[TOPICS[j]] = 0;
        toAdd.target[TOPICS[j]] = 0;
      }
      numLinksDict[nodes_not_filtered[i].id] = toAdd;
    }
    for (let i = 0; i < links_not_filtered.length; i++) {
      const l = links_not_filtered[i];
      numLinksDict[l.target].target[l.topic] += l.value;
      numLinksDict[l.source].source[l.topic] += l.value;
    }
  };


  const create_not_filteredFromJSON = async () => {
    return d3.json('final_data.json').then(data => {
        links_not_filtered = data.links.map(d => Object.assign({}, d)).filter(l => l.target != l.source);
        nodes_not_filtered = data.nodes.map(d => Object.assign({}, d));
    });
  };

  const assignFilter = filterResult => [nodes, node_ids, links] = filterResult;

  const transferNot_filteredToArrays = () => {
    assignFilter(filterStudents(nodes_not_filtered, links_not_filtered, n => {
      if (currentTopic == "All") {
        return sumObj(numLinksDict[n.id].target) >= minNumConnections;
      }
      else {
        return numLinksDict[n.id].target[currentTopic] >= minNumConnections;
      }
    }));
  };

  const initializeDefs = () => {
    linearGradient = d3.select("defs").selectAll("linearGradient");
  };

  const getGradientID = l => {
    let sForm, tForm;
    try {
      sForm = l.source.id.replace(/\W/g, '_');
    }
    catch {
      sForm = l.source.replace(/\W/g, '_');
    }

    try {
      tForm = l.target.id.replace(/\W/g, '_');
    }
    catch {
      tForm = l.target.replace(/\W/g, '_');
    }

    return `gradient_${sForm}|${tForm}`
  };

  const registerLinearGradients = links => {
    //console.log("Registering liear gradients");
    const elem = linearGradient.data(links, l => getGradientID(l));
    //console.log(links);
    elem.exit()
      .each(function(e,i) {
        const d = d3.select(this);
        document.remove(linearGradient[getGradientID(d)]);
        delete linearGradient[getGradientID(d)];
      })
      .remove();

    const enter = elem.enter().append("linearGradient")
      .attr("gradientUnits", "userSpaceOnUse")
      .attr("id", d => getGradientID(d))
      .attr("x1", 0)
      .attr("x2", 1)
      .attr("y1", 0)
      .attr("y2", 0);

    enter.append("stop").attr("offset", "0%").attr("stop-color", "rgba(" + RGB_LINE_COLOR + ",1)");
    enter.append("stop").attr("offset", "100%").attr("stop-color", "rgba(" + RGB_LINE_COLOR + ",0)");
    
    d3.select("defs").selectAll("linearGradient").each(function(e,i) {
      //console.log(i, d, this);
      //console.log(this);
      const d = d3.select(this)
      linearGradientDict[getGradientID(e)] = d;}/*(e, i) => {
      console.log(e, i);
        const d = d3.select(this);
        console.log(d);
        linearGradientDict[getGradientID(d)] = d;
      }*/);
  };

  const condenseLinksforSimulation = ls => {
    let toReturn = [];
    for (let l of ls) {
      condensed = false;
      for (let i = 0; i < toReturn.length; i++) {
        r = toReturn[i];
        let lTargStr;
        let rTargStr;
        let lSourStr;
        let rSourStr;
        if (typeof l.target == 'string') lTargStr = l.target;
        else lTargStr = l.target.id;
        if (typeof r.target == 'string') rTargStr = r.target;
        else rTargStr = r.target.id;
        if (typeof l.source == 'string') lSourStr = l.source;
        else lSourStr = l.source.id;
        if (typeof r.source == 'string') rSourStr = r.source;
        else rSourStr = r.source.id;
        //console.log(lTargStr, rTargStr, lSourStr, rSourStr);
        if ((lTargStr== rTargStr && lSourStr == rSourStr) || (lTargStr == rSourStr && lSourStr == rTargStr)) {
          toReturn[i].value += l.value;
          condensed = true;
          break;
        }
      }
      if (!condensed) {
        delete l.topic;
        toReturn.push(l);
      }
    }

    //reregisterLinearGradients(toReturn);

    return toReturn;
  };
  
  const calculateMaxStrength = () => {
    maxStrength = 0;
      links.forEach(l => {
        if (l.value > maxStrength) {
          maxStrength = l.value;
        }
      });
  }

const setLabs = node_ids => labs = getAllLabs(node_ids).sort();

const setCurrentLabHighlightList = () => currentLabHighlightList = labs;

const calculateSimulationStrength = (d, maxstrength) => (d => MINIMUM_STRENGTH_CONSTANT + Math.sqrt((normalize(d.value, 0, maxStrength) * 10 + 1) / SCALE_FACTOR)); // so that it returns the callback function

const createSimulation = () => {
    simulation = d3.forceSimulation(nodes)
    .force("boundary", forceBoundary(forceBoundaryMargin,forceBoundaryMargin,width-forceBoundaryMargin, height-forceBoundaryMargin))
    .force("link", d3.forceLink(links).id(d => d.id).strength(d => calculateSimulationStrength(d, maxStrength)))
    .force("charge", d3.forceManyBody().strength(-60)/*(d3.forceManyBody().strength(-50 / SCALE_FACTOR)*/)
    .force("center", d3.forceCenter(width / 2, height / 2));
};

const createAndFormatSVG = () => {
     svg = d3.select("svg")
    .attr("width", width)
    .attr("height", height)
    .attr("viewBox", [0, 0, width, height])
    .style("max-width", "100%")
    .style("height", "auto")
    .style("background-color", "white");

    transformation = svg.node().getCTM();
   svgPoint = svg.node().createSVGPoint();
   boundingRect = svg.node().getBoundingClientRect();

};

const linksToLink = isFirst => {
    if (isFirst) gl = svg.append("g").attr("transform", "translate(150, -10)");

    const sel = gl.selectAll("path").data(condenseLinksforSimulation(links), l=>uniqueId(l));
    
    sel.exit()
        .remove();

    sel.enter().append("path").merge(sel)
        .attr("fill", "none") //ADDED
        .attr("stroke-width", LINE_WIDTH/*d => Math.sqrt(d.value)*/) // for 
        .style("stroke-linecap", "round")
        .attr("opacity", data => (normalize(data.value, 0, maxStrength) / 2 + 0.5)/ SCALE_FACTOR);
        //console.log("do I need to set opacity here?");

    return sel;
};

const calculateMinMaxMapFromFiltered = () => { // now it's not "FromFiltered"
    [...TOPICS, "All"].forEach(topic => {
        minMaxMap[topic] = calculateMinMax(nodes_not_filtered, links_not_filtered, topic);
      });
};

const nodesToNodeAndFormat = () => {
    node = svg.append("g").attr("transform", "translate(150, -10)");
    g = node;
};

const configureNode = (node, nodes) => {    
    const sel = g.selectAll("circle").data(nodes, n=>n.id);
    
    sel.exit()
        .remove();

    const ent = sel.enter().append("circle").merge(sel);
    
    ent.attr("r", data => referenceCache[data.id]["All"]);
    
    ent.attr("fill", d => {
            const lab = d.id.split(";")[1].split("/")[5]; 
            return colorRegion(LABS_CONTINENT[lab]);
        })
        .attr("opacity", NODE_HIGHLIGHTED_OPACITY)
        .call(d3.drag()
        .on("start", dragstarted)
        .on("drag", dragged)
        .on("end", dragended));

    return g.selectAll("circle");
};

function dragstarted(event, d) {
    objectBeingDragged = d3.select(this);
    if (!event.active) simulation.alphaTarget(0.3).restart();
    d.fx = d.x;
    d.fy = d.y;
    mouseIsDragging = true;
  }

  function dragged(event, d) {
    d.fx = event.x;
    d.fy = event.y;
  }

  function dragended(event, d) {
    if (!event.active) simulation.alphaTarget(0);
    d.fx = null;
    d.fy = null;
    mouseIsDragging = false;
    console.log("dragend", pointerOutOfSVG());
    const pointerOut = pointerOutOfSVG();
    if (pointerOut) {
      tooltipMouseleave(null, null, objectBeingDragged);
    }
    objectBeingDragged = null;
  }

  const getSimulationForceLinkDistance = d => referenceCache[d.target.id][currentTopic] + referenceCache[d.source.id][currentTopic];// this is good but it doesn't completely fix the circle overlapping problem because of circles that are touching but aren't linked  //Math.max(referenceCache[d.target.id][currentTopic], referenceCache[d.source.id][currentTopic]);

  const calibrateSimulation = () => {
    simulation.force("collision", forceCollide.radius(d => d.r / 1.2));

    simulation.force("link", d3.forceLink(links).id(d => d.id).distance(d => {
      return getSimulationForceLinkDistance(d);
    }));
  };

  /*const setNodeTooltips = node => {
    /*let r = node.append("title")
    .text(d => {
      return d.id.split(";")[0];
    });
    
  r = node.on('click', (d, i) => { window.open(i.id.split(";")[1], "_blank") });

  return r;
  };*/

  //const activationCheck = (year, lab) => (year == currentYear || currentYear == "All") && (currentLabHighlightList.includes(lab));
  const activationCheck = (currentYear, currentLabHighlightList, year, lab) => (year == currentYear || currentYear == "All") && (currentLabHighlightList.includes(lab));

  const linkTick = () => {
    link.attr("d", d => {
      const gradientID = getGradientID(d);
      //const lg = linearGradientDict[gradientID];
      const lg = document.getElementById(gradientID);
      /*lg.attr("x1", d.source.x)
        .attr("y1", d.source.y)
        .attr("x2", d.target.x)
        .attr("y2", d.target.y)*/
      const {source,
        sourceYear,
        sourceLab,
        target,
        targetYear,
        targetLab} = getLinkSummary(d);
      const sourceIsActivated = activationCheck(sourceYear, sourceLab);
      const targetIsActivated = activationCheck(targetYear, targetLab);
      if (!((sourceIsActivated && targetIsActivated) || (!(sourceIsActivated || targetIsActivated)))) { // if only one is activated
        if (sourceIsActivated) {
          lg.setAttribute("x1", d.source.x);
          lg.setAttribute("y1", d.source.y);
          lg.setAttribute("x2", d.target.x);
          lg.setAttribute("y2", d.target.y);
        }
        else {
          lg.setAttribute("x2", d.source.x);
          lg.setAttribute("y2", d.source.y);
          lg.setAttribute("x1", d.target.x);
          lg.setAttribute("y1", d.target.y);
        }
      }

      const path = d3.path();
      path.moveTo(d.source.x, d.source.y);
      path.lineTo(d.target.x, d.target.y);
      return path.toString();  // return the path data as a string
      /*const path = d3.path();
      path.moveTo(d.source.x, d.source.y);
      path.lineTo(d.target.x, d.target.y);
      const gradientID = getGradientID(d);
      const lg = linearGradientDict[gradientID];
      lg.attr("x1", d.source.x);
      lg.attr("x2", d.target.x);
      lg.attr("y1", d.source.y);
      lg.attr("y2", d.target.y);
      console.log(lg);
      return path;*/
    });
  };

  const setSimulationTick = (node, link) => {

    linkTick(); // so that the directions and everything are correct before the user first drags on the simulation
    simulation.on("tick", () => {
        /*link
          .attr("x1", d => d.source.x)
          .attr("y1", d => d.source.y)
          .attr("x2", d => d.target.x)
          .attr("y2", d => d.target.y);*/
        
        linkTick();
        
        node
          .attr("cx", d => d.x)
          .attr("cy", d => d.y)
      });
  };

  const selectByTopic = topic => {
    currentTopic = topic;
    let maxStrength = 0;
    links.forEach(l => {
      if (l.value > maxStrength && (l.topic == topic || topic == "All")) {
        maxStrength = l.value;
      }
    });

    link
      .attr('opacity', data => {
        if (data.topic == topic || topic == "All") {
          return (normalize(data.value, 0, maxStrength) / 2 + 0.5) / SCALE_FACTOR;
        }
        else {
          return 0;
        }
      });
      //console.log("also do I need to set opacity for lines here?");

    simulation
      .force("link", d3.forceLink(links).id(d => d.id)
        .strength(d => calculateSimulationStrength(d, maxStrength))
        .distance(d => getSimulationForceLinkDistance(d)));

    let topicLinks = [];
    links.forEach(l => {
      if (l.topic == topic || topic == "All") {
        topicLinks.push(l);
      }
    });
    
    node.attr("r", data => referenceCache[data.id][topic]);
      simulation.force("link", d3.forceLink(topicLinks).id(d => d.id).distance(d => getSimulationForceLinkDistance(d)));
      forceCollide.initialize(nodes);
      simulation.alpha(1).restart();
    };

const configureGlowDefinitions = () => {
    defs = svg.append("defs");

  //Filter for the outside glow
  defs.append("filter")
      .attr("id", "sofGlow")
      .attr("width", "300%")
      .attr("height", "300%")
      .attr("x", "-100%")
      .attr("y", "-100%")
      .attr("stdDeviation","1")
      .attr("result","coloredBlur")
      .append("feGaussianBlur")
      .attr("in", "thicken")
      .attr("stdDeviation", "1")
      .attr("result", "blurred");
};

const getLinkSummary = data => {
  const source = data.source.id;
  const sourceYear = source.split(";")[1].split("/")[3];
  const sourceLab = source.split(";")[1].split("/")[5];
  const target = data.target.id;
  const targetYear = target.split(";")[1].split("/")[3];
  const targetLab = target.split(";")[1].split("/")[5];
  return {
    source,
    sourceYear,
    sourceLab,
    target,
    targetYear,
    targetLab
  };
};

const setLinkOpacity = () => {
  link.attr("opacity", data => {
    const {source,
      sourceYear,
      sourceLab,
      target,
      targetYear,
      targetLab} = getLinkSummary(data);
    let sourceIsOn = false;
    let targetIsOn = false;

    if (activationCheck(sourceYear, sourceLab)) {
      sourceIsOn = true;
    } 
    if (activationCheck(targetYear, targetLab)) {
      targetIsOn = true;
    }

    if ((sourceIsOn || targetIsOn) && !(sourceIsOn && targetIsOn)) {
      return null;
      /*if (sourceIsOn) {
        return "url(#LineFadeForward)";
      }
      return "url(#LineFadeBackward)";*/
    }
    return 1;
  });
  link.attr("stroke", data => { // SHOULD USE LINKS FROM SIMULATION BC OF CONDENSING?
    const source = data.source.id;
    const sourceYear = source.split(";")[1].split("/")[3];
    const sourceLab = source.split(";")[1].split("/")[5];
    const target = data.target.id;
    const targetYear = target.split(";")[1].split("/")[3];
    const targetLab = target.split(";")[1].split("/")[5];
    let sourceIsOn = false;
    let targetIsOn = false;
    
    if ((sourceYear == currentYear || currentYear == "All") && (currentLabHighlightList.includes(sourceLab))) {
      sourceIsOn = true;
    } 
    if ((targetYear == currentYear || currentYear == "All") && (currentLabHighlightList.includes(targetLab))) {
      targetIsOn = true;
    }

    if (sourceIsOn && targetIsOn) {
      return "rgba(255,255,255"+((normalize(data.value, 0, maxStrength) / 2 + 0.5)/ SCALE_FACTOR).toString()+")";
    }
    else if (sourceIsOn || targetIsOn) {
      return `url(#${getGradientID(data)})`;
      /*if (sourceIsOn) {
        return "url(#LineFadeForward)";
      }
      return "url(#LineFadeBackward)";*/
    }
    else {
      return "rgba(255,255,255,0.05)";
    }
  });
};

const setYear = year => {
    currentYear = year;
    /*node.attr("opacity", data => {
      const y = data.id.split(";")[1].split("/")[3];
      const lab = data.id.split(";")[1].split("/")[5];
      if ((y == year || year == "All") && currentLabHighlightList.includes(lab)) {
        return NODE_HIGHLIGHTED_OPACITY;
      }
      else {
        return minOpacity;
      }
    });
    setLinkOpacity();
    linkTick();*/
    updateData({
      minNumConnections,
      simulation,
      svg,
      g,
      "gl": gl_
    })
  };

const createPie = () => {
    const pieG = svg.append("g")
    .attr("transform", "translate(" + pieX + "," + pieY + ") rotate(" + 360/14 + ")");

  var pieData = {"All": 1};

  for (let i = 2018; i <= 2023; i++) {
    pieData[i] = 1;
  }

  var pieColor = d3.scaleOrdinal()
  .domain(Object.keys(pieData))
  .range(COLOR_PALETTE);

  var pie = d3.pie()
  .value(function(d) {return d.value; })
  var data_ready = pie(Object.entries(pieData).map(([key, value]) => ({key, value})));

  var arcGenerator = d3.arc()
  .innerRadius(50)
  .outerRadius(pieRadius)

  const rotatePie = d => {
    var rotate = -((d.startAngle + d.endAngle) / 2);
    pieG.transition()
      .duration(1000)
      .attr("transform", "translate(" + pieX + "," + pieY + ") rotate(" + (rotate / Math.PI * 180) + ")");
  };

  pieG
    .selectAll('mySlices')
    .data(data_ready)
    .enter()
    .append('path')
      .attr('d', arcGenerator)
      .attr('fill', PIE_SLICE_COLOR/*d => colorFab(d.data.key)*/)
      .attr("stroke", "white")
      .style("stroke-width", "2px")
      .style("opacity", 1)
      .on('click', function (event, d) {
          // Rotate pie to clicked segment
          setYear(d.data.key);
          rotatePie(d);
        });

  pieG
  .selectAll('mySlices')
  .data(data_ready)
  .enter()
  .append('text')
  .text(function(d){ return d.data.key})
  .attr("dy", "0.3em")
  .attr("transform", function(d) { return "translate(" + arcGenerator.centroid(d) + ") rotate(" + (d.startAngle + d.endAngle)/2 * (180/Math.PI) + ")";  })
  .style('text-anchor', 'middle')
  .style('fill', PIE_TEXT_COLOR)
  .attr("font-weight", 700)
  .attr("font-family", "Saira")
  .style("font-size", 18)
  .on('click', function (event, d) {
    // Rotate pie to clicked segment
    setYear(d.data.key);
    rotatePie(d);
  });
};

const createReferenceCache = () => {
  referenceCache = {};
  ["All", ...TOPICS.slice(1, -1)].forEach(topic => {
    nodes_not_filtered.forEach(data => {
      let r = 0;
      links_not_filtered.forEach(l => {
        if (l.target == data.id && (topic == "All" || l.topic == topic)) {
          r += l.value;
        }
      });
      r = normalize(r, minMaxMap[topic].min, minMaxMap[topic].max) * NODE_SIZE_MULTIPLIER * ((1 - (1/minMaxMap[topic].max))/2) + NODE_SIZE_MINIMUM;
      r /= SCALE_FACTOR;
      data.r = r;
      if (!(data.id in referenceCache)) referenceCache[data.id] = {};
      referenceCache[data.id][topic] = r;
    });
  });
};

const centerText = (txt, xPos) => {
  let textWidth = txt.node().getBBox().width;
    txt.attr("x", (xPos - (textWidth / 2)));
};

window.addEventListener('pointermove', (event) => {
  mousePos = { x: event.clientX, y: event.clientY };
  /*Tooltip.style("left", (mousePos.x + body.scrollLeft + 50) + "px"); // offset good aesthetically and prevents "event bubbling" when tooltip blocks circle
  Tooltip.style("top", (mousePos.y + body.scrollTop - 10) + "px");*/

  let tooltipWidth = Tooltip.node().offsetWidth; // Width of the tooltip
  let tooltipHeight = Tooltip.node().offsetHeight; // Height of the tooltip
  let windowWidth = document.documentElement.clientWidth; // Width of the window
  let windowHeight = document.documentElement.clientHeight; // Height of the window
  
  let x = event.clientX + body.scrollLeft + 50;
  let y = event.clientY + body.scrollTop - 10;

  //console.log("y", y, "event.clientY", event.clientY, "scrollTOp", body.scrollTop, "tooltipHeight", tooltipHeight, "windowHeight", windowHeight);

  //console.log(x, tooltipWidth, innerWidth);

  // Consider a buffer of 10 pixels or so to ensure that 
  // the tooltip doesn't touch the edge of the viewport.
  let buffer = {"x": 50, "y": 10};

  // If the tooltip would go off the right side of the screen
  if (x + tooltipWidth + buffer.x - body.scrollLeft > windowWidth) {
    x = x - tooltipWidth - (50 * 2);
  }

  // If the tooltip would go off the bottom of the screen
  if (y + tooltipHeight + buffer.y - body.scrollTop > windowHeight) {
    y = y - tooltipHeight + (10*2);
  }

  Tooltip.style("left", x + "px");
  Tooltip.style("top", y + "px");
});

const pointerOutOfSVG = () => {
  const el = document.elementFromPoint(mousePos.x, mousePos.y);
  return !(svg.node() === el || svg.node().contains(el));
};

const tooltipMouseover = function(event, d) {
  if (mouseIsOver) return;
  mouseIsOver = true;
  //console.log("mouseover");
  Tooltip
    .style("display", "initial")
    .style("visibility", "visible");
  
  d3.select(this)
    .style("stroke", HOVER_NODE_STROKE_COLOR)
    .style("stroke-width", NODE_STROKE_WIDTH_HIGHLIGHTED);
}

var tooltipMousemove = function(event, d) {
  //console.log("mousemove");
  //var pos = cursorPoint(event);
  //pos = {"x": d.x, "y": d.y};
  Tooltip
    .html("<span>Student: " + d.id.split(";")[0] + "<br>Year: " + d.id.split(";")[1].split("/")[3] + "<br>Lab: " + d.id.split(";")[1].split("/")[5] + "<br>Region: <span style=\"color:"+colorRegion(LABS_CONTINENT[d.id.split(";")[1].split("/")[5]])+";\">" + LABS_CONTINENT[d.id.split(";")[1].split("/")[5]] + "</span></span>");
    //.style("left", (pos.x + 70) + "px")
    //.style("top", (pos.y) + "px");
}

var tooltipMouseleave = function(event, d, obj=null) {
  if (mouseIsDragging) return;
  mouseIsOver = false;
  Tooltip
    .style("display", "none")
    .style("visbility", "hidden");

  (obj == null ? d3.select(this) : obj)
    .style("stroke", NOT_HOVERING_NODE_STROKE_COLOR)
    .style("stroke-width", NOT_HOVERING_NODE_STROKE_WIDTH/*"white"*/);
}

const NODE_STROKE_WIDTH_HIGHLIGHTED = "1.5px",
      HOVER_NODE_STROKE_COLOR = "black",
      NOT_HOVERING_NODE_STROKE_WIDTH = "0px",
      NOT_HOVERING_NODE_STROKE_COLOR = "",
      RGB_LINE_COLOR = "0,0,0",
      LINE_WIDTH = "0.3px",
      CAROUSEL_RECT_STROKE_COLOR = "",
      CAROUSEL_RECT_STROKE_WIDTH = "0px",
      CAROUSEL_SELECTOR_COLOR = "black",
      DIAL_OUTLINE_COLOR = "grey"/*FAB_PALETTE[0]*/,
      DIAL_TEXT_COLOR = "black"/*"white"*/,
      OVERLAY_TEXT_LINK_COLOR = "#7e7eed"/*"#aaaaff"*/;

      // TO MODIFY WITH CSS: tooltip stroke + stroke-width, can make node stroke more efficient, text color

const SCALE_FACTOR = 1,
      forceBoundaryMargin = 30;

const minOpacity = 0.15;

const NODE_HIGHLIGHTED_OPACITY = 1;
const MINIMUM_STRENGTH_CONSTANT = 100;

const PIE_SLICE_COLOR = 'grey',
    PIE_TEXT_COLOR = 'white',
    DIAL_STICK_COLOR = 'grey',
    CAROUSEL_OPTION_COLOR = 'grey',
    CAROUSEL_TEXT_COLOR = 'white';

const COLOR_PALETTE = ["#3957ff", "#d3fe14", "#c9080a", "#fec7f8", "#0b7b3e", "#0bf0e9", "#c203c8", "#fd9b39", "#888593", "#906407", "#98ba7f", "#fe6794", "#10b0ff", "#ac7bff", "#fee7c0", "#964c63", "#1da49c", "#0ad811", "#bbd9fd", "#fe6cfe", "#297192", "#d1a09c", "#78579e", "#81ffad", "#739400", "#ca6949", "#d9bf01", "#646a58", "#d5097e", "#bb73a9", "#ccf6e9", "#9cb4b6", "#b6a7d4", "#9e8c62", "#6e83c8", "#01af64", "#a71afd", "#cfe589", "#d4ccd1", "#fd4109", "#bf8f0e", "#2f786e", "#4ed1a5", "#d8bb7d", "#a54509", "#6a9276", "#a4777a", "#fc12c9", "#606f15", "#3cc4d9", "#f31c4e", "#73616f", "#f097c6", "#fc8772", "#92a6fe", "#875b44", "#699ab3", "#94bc19", "#7d5bf0", "#d24dfe", "#c85b74", "#68ff57", "#b62347", "#994b91", "#646b8c", "#977ab4", "#d694fd", "#c4d5b5", "#fdc4bd", "#1cae05", "#7bd972", "#e9700a", "#d08f5d", "#8bb9e1", "#fde945", "#a29d98", "#1682fb", "#9ad9e0", "#d6cafe", "#8d8328", "#b091a7", "#647579", "#1f8d11", "#e7eafd", "#b9660b", "#a4a644", "#fec24c", "#b1168c", "#188cc1", "#7ab297", "#4468ae", "#c949a6", "#d48295", "#eb6dc2", "#d5b0cb", "#ff9ffb", "#fdb082", "#af4d44", "#a759c4", "#a9e03a", "#0d906b", "#9ee3bd", "#5b8846", "#0d8995", "#f25c58", "#70ae4f", "#847f74", "#9094bb", "#ffe2f1", "#a67149", "#936c8e", "#d04907", "#c3b8a6", "#cef8c4", "#7a9293", "#fda2ab", "#2ef6c5", "#807242", "#cb94cc", "#b6bdd0", "#b5c75d", "#fde189", "#b7ff80", "#fa2d8e", "#839a5f", "#28c2b5", "#e5e9e1", "#bc79d8", "#7ed8fe", "#9f20c3", "#4f7a5b", "#f511fd", "#09c959", "#bcd0ce", "#8685fd", "#98fcff", "#afbff9", "#6d69b4", "#5f99fd", "#aaa87e", "#b59dfb", "#5d809d", "#d9a742", "#ac5c86", "#9468d5", "#a4a2b2", "#b1376e", "#d43f3d", "#05a9d1", "#c38375", "#24b58e", "#6eabaf", "#66bf7f", "#92cbbb", "#ddb1ee", "#1be895", "#c7ecf9", "#a6baa6", "#8045cd", "#5f70f1", "#a9d796", "#ce62cb", "#0e954d", "#a97d2f", "#fcb8d3", "#9bfee3", "#4e8d84", "#fc6d3f", "#7b9fd4", "#8c6165", "#72805e", "#d53762", "#f00a1b", "#de5c97", "#8ea28b", "#fccd95", "#ba9c57", "#b79a82", "#7c5a82", "#7d7ca4", "#958ad6", "#cd8126", "#bdb0b7", "#10e0f8", "#dccc69", "#d6de0f", "#616d3d", "#985a25", "#30c7fd", "#0aeb65", "#e3cdb4", "#bd1bee", "#ad665d", "#d77070", "#8ea5b8", "#5b5ad0", "#76655e", "#598100", "#86757e", "#5ea068", "#a590b8", "#c1a707", "#85c0cd", "#e2cde9", "#dcd79c", "#d8a882", "#b256f9", "#b13323", "#519b3b", "#dd80de", "#f1884b", "#74b2fe", "#a0acd2", "#d199b0", "#f68392", "#8ccaa0", "#64d6cb", "#e0f86a", "#42707a", "#75671b", "#796e87", "#6d8075", "#9b8a8d", "#f04c71", "#61bd29", "#bcc18f", "#fecd0f", "#1e7ac9", "#927261", "#dc27cf", "#979605", "#ec9c88", "#8c48a3", "#676769", "#546e64", "#8f63a2", "#b35b2d", "#7b8ca2", "#b87188", "#4a9bda"]

const FAB_PALETTE = [
  "#f1f2f2",
  "#f1d2f2",
  "#f1b2f2",
  "#f04260",
  "#4abfbd",
  "#284fb5",
  "#f05c71"
];

const NODE_REGION_PALETTE = [
  "#1da619",
  "#f04260",
  "#4abfbd",
  "#284fb5",
  "#f05be1"
];
const continent = [
  "Africa",
  "Asia",
  "Europe",
  "North America",
  "South America"
];
const continentColor = {};
for (let i = 0; i < NODE_REGION_PALETTE.length; i++) continentColor[continent[i]] = NODE_REGION_PALETTE[i];

const NODE_SIZE_MULTIPLIER = 50;
const NODE_SIZE_MINIMUM = 5;

const TOPICS = [
  "Prefab",
  "Computer-Aided Design",
  "Computer-Controlled Cutting",
  "Embedded Programing",
  "3D Scanning and Printing",
  "Electronics Design",
  "Computer-Controlled Machining",
  "Electronics Production",
  "Mechanical Design, Machine Design",
  "Input Devices",
  "Moulding and Casting",
  "Output Devices",
  "Embedded Networking and Communications",
  "Interface and Application Programming",
  "Wildcard Week",
  "Applications and Implications",
  "Invention, Intellectual Property and Business Models",
  "Final Project",
  "Other"
]

const nonDiacriticLetters = "abcdefghijklmnopqrstuvwxyz";

const width = 2*928;
const height = 1.5*600;
const color = d3.scaleOrdinal().range(COLOR_PALETTE);
//const color = d3.scaleOrdinal().range(NODE_REGION_PALETTE);//d3.scaleOrdinal().range(COLOR_PALETTE);
const colorRegion = key => {
  return continentColor[key];
};
const colorFab = d3.scaleOrdinal().range(FAB_PALETTE);
const shape = d3.scaleOrdinal().range(d3.symbols);

const radius_dict = {};

const forceCollide = d3.forceCollide();

const pieX = 210, pieY = 720;
const pieRadius = 100;

const topicCarouselList = ["All", ...TOPICS.slice(1, -1)];

const initializeCarousel = (callback, carousel_data, width, height, x, y, svg, colorPalette) => {

    const g = svg.append("g");

    const yScale = d3.scaleBand()
        .range([ 0, height ])
        .domain(carousel_data)
        .padding(0.2);

    const color = d3.scaleOrdinal().range(colorPalette);

    const rect = g.selectAll("rect")
        .data(carousel_data)
        .enter()
        .append("rect")
        .attr('x', 10 + x)
        .attr('y', d => yScale(d) + y)
        .attr('width', width)
        .attr('height', yScale.bandwidth())
        .attr('stroke', CAROUSEL_RECT_STROKE_COLOR)
        .attr('stroke-width', CAROUSEL_RECT_STROKE_WIDTH)
        .attr('fill', CAROUSEL_OPTION_COLOR/*d => color(d)*/)
        .on('click', (event, d) => {
            movePointerTo(d);
        });

    var outerWidth = ((height / carousel_data.length) - yScale.bandwidth()) + width, outerHeight = height / carousel_data.length;
    var innerWidth = width, innerHeight = yScale.bandwidth();
    
    var outerRectangle = { top: yScale(carousel_data[0]) + ((yScale.bandwidth() - (height / carousel_data.length)))/2, left: 10 - ((height / carousel_data.length) - yScale.bandwidth())/2, width: outerWidth, height: outerHeight };
    var innerRectangle = { 
        top: outerRectangle.top + (outerHeight - innerHeight) / 2, 
        left: outerRectangle.left + (outerWidth - innerWidth) / 2,
        width: innerWidth,
        height: innerHeight
    };
    
    var pathData = [
        "M", outerRectangle.left, outerRectangle.top, // Move to the top-left corner of the outer rectangle
        "h", outerWidth, // Draw the top side
        "v", outerHeight, // Draw the right side
        "h", -outerWidth, // Draw the bottom side
        "v", -outerHeight, // Draw the left side
        "M", innerRectangle.left, innerRectangle.top, // Move to the top-left corner of the inner rectangle
        "h", innerWidth, // Draw the top side
        "v", innerHeight, // Draw the right side
        "h", -innerWidth, // Draw the bottom side
        "v", -innerHeight, // Draw the left side
        "Z" // Close the path
    ].join(" ");
    var defs = g.append("defs");

    var mask = defs.append("mask")
        .attr("id", "myMask");
    
    // Add a white rectangle to the mask
    mask.append("rect")
        .attr("x", x)
        .attr("y", y)
        .attr("width", "100%")
        .attr("height", "100%")
        .attr("fill", "white");
    
    // Add a smaller black rectangle to the mask to cut out
    mask.append("rect")
        .attr("x", innerRectangle.left + x)
        .attr("y", innerRectangle.top + y)
        .attr("width", innerRectangle.width)
        .attr("height", innerRectangle.height)
        .attr("fill", "black");
    
    // Draw a rectangle with the mask
    const selectionRect = g.append("rect")
        .attr("x", outerRectangle.left + x)
        .attr("y", outerRectangle.top + y)
        .attr("width", outerRectangle.width)
        .attr("height", outerRectangle.height)
        .attr("fill", CAROUSEL_SELECTOR_COLOR)
        .attr("mask", "url(#myMask)");

    const movePointerTo = d => {
        selectionRect.transition()
            .duration(1000)
            .attr('transform', "translate(0, " + (yScale(d) - yScale(carousel_data[0])) + ")");
            callback(d);
    };

    const text = g.selectAll("text")
        .data(carousel_data)
        .enter()
        .append("text")
        .attr('x', 10 + width/2 + x)
        .attr('y', d => yScale(d) + yScale.bandwidth()/2 + y)
        .attr('dy', '0.3em')
        .text(d => d)
        .on('click', (event, d) => {
            movePointerTo(d);
        });

    text
        .style('text-anchor', 'middle')
        .style('fill', CAROUSEL_TEXT_COLOR/*d => {if (d == 'Electronics Design' || d == "Embedded Networking and Communications") return 'white';return 'black';}*/)
        .attr("font-weight", 700)
        .attr("font-family", "Saira")
        .attr("font-size", 13)
};

let prevSentToCallback;
const strokeWidth = 12;
const dialY = pieY;
const dialX = width - pieX;

const generateDialMapScale = () => {
    //mapMin = 
    return d3.scaleLinear().domain([startDegree, endDegree]).range([clamp(mapMin, 1, Infinity), mapMax])
};

const updateDialText = (currentDialDeg, callback) => {
    if (!dialGroup) return;
    dialGroup.attr("transform", `translate(${dialX}, ${dialY}) rotate(${currentDialDeg})`);
            
    var mapScale = generateDialMapScale();
    var mappedValue = mapScale(currentDialDeg);

    const rounded = Math.round(mappedValue);

    numText
        .text(rounded);
    numTextWidth = numText.node().getBBox().width;
    numText.attr("x", (dialX - (numTextWidth / 2)));
    
    callback(rounded);//return rounded;
};

function convertSVGtoScreenCoordinates(svgElement, dialX, dialY) {
    var pt = svgElement.createSVGPoint();
    pt.x = dialX;
    pt.y = dialY;
    
    // getScreenCTM returns the matrix that transforms current user units to screen coordinates.
    var svgP = pt.matrixTransform(svgElement.getScreenCTM());
    
    return {
        x: svgP.x,
        y: svgP.y
    };
}

function calculateAngle(center, point) {
    let dy = point.y - center.y;
    let dx = point.x - center.x;
    let theta = Math.atan2(dy, dx);
    return theta;
  }

const initializeDial = (svg, callback) => {
    var width = +svg.attr("width"),
        height = +svg.attr("height"),
        radius = pieRadius - (strokeWidth/2); // to be same as the year-select pie

    // Get the input element for displaying the mapped value
    var inputElement = document.getElementById("value-input");

    const clamp = (num, min, max) => Math.min(Math.max(num, min), max);
    const sensitivity = 1;

    const textElem = svg.append("text");
    textElem
        .attr("x", dialX)
        .attr("y", dialY + (radius + (strokeWidth*2)))
        .text("Minimum Times Referenced")
        .attr("font-family", "sans-serif")
        .attr("font-size", "13px")
        .attr("fill", DIAL_TEXT_COLOR);
    centerText(textElem, dialX);

    numText = svg.append("text");
    numText
        .attr("x", dialX)
        .attr("y", dialY + ((radius/2) + strokeWidth))
        .text("20")
        .attr("font-family", "sans-serif")
        .attr("font-size", "40px")
        .attr("fill", DIAL_TEXT_COLOR);
    let numTextWidth = numText.node().getBBox().width;
    numText.attr("x", (dialX - (numTextWidth / 2)));

    window.addEventListener('mousemove', (event) => {
        mousePos = { x: event.clientX, y: event.clientY };
      });

    var drag = d3.drag()
        .on("start", (event, d) => {
            //d.x = event.x;
            d.x = event.sourceEvent.clientX;// mousePos.x;
            d.y = event.sourceEvent.clientY;//mousePos.y;            
            if (!d.currentDeg) d.currentDeg = startPos;
        })
        .on("drag", (event, d) => {
           /* var delta = event.x - d.x,
                degDelta = delta * sensitivity;

            // Constrain the rotation within the start and end degree
            d.degNew = clamp(degDelta + d.currentDeg, startDegree, endDegree);
            currentDialDeg = d.degNew;

            updateDialText(currentDialDeg, callback);*/

            let vals = convertSVGtoScreenCoordinates(document.getElementsByTagName('svg')[0], dialX, dialY);

            /*let h = vals.x,
                k = vals.y,
                x1 = d.x,
                y1 = d.y,
                x2 = event.sourceEvent.clientX,//mousePos.x,//event.x,
                y2 = event.sourceEvent.clientY;//mousePos.y;//event.y;

            console.log(h,k,x1,y1,x2,y2);
            
            let m = Math.sqrt(Math.pow(x2-h,2)+Math.pow(y2-k,2));
            let e = Math.sqrt(Math.pow(x1-h,2)+Math.pow(y1-k,2));
            let g = y1 - k;
            let j = Math.sqrt(Math.abs(Math.pow(e,2) - Math.pow(g,2)));
            let n0 = Math.atan(g/j);
            let p = Math.cos(n0) * m;            
            let h2 = Math.sqrt(Math.abs(Math.pow(m, 2) - Math.pow(Math.cos(n0)*m, 2)));
            let q = h2/(Math.tan(90 - (n0/2)));
            let zDeg = Math.acos((x2-h)/(y2-k));
            let mDeg = zDeg - n0;
            let r = (p+q)/(Math.cos(mDeg));
            let s = Math.sqrt(Math.abs(Math.pow(p+q, 2) - Math.pow(r, 2)));

            let x1t = x1 + (e - Math.sqrt(Math.pow(e,2)-Math.pow(g,2)));
            let y1t = k;
            let x2t = h+r;
            let y2t = k+s;

            let theta = Math.atan((y2t-y1t)/(x2t-h)) * (180/Math.PI);
            console.log("NUMS", h,k,x1,y1,x2,y2,m,e,g,h,n0,p,h2,q,"Z",zDeg,mDeg,r,s,x1t,y1t,x2t,y2t,theta);*/
            let newXY = {"x": event.sourceEvent.clientX, "y": event.sourceEvent.clientY};
            let theta = calculateAngle(vals, /*mousePos*/newXY);
            let thetaDegrees = theta * (180/Math.PI);
            let oldXY = {"x": d.x, "y": d.y};
            let oldAngle = calculateAngle(vals, oldXY);
            let oldAngleDegrees = oldAngle * (180/Math.PI)
            let angleDelta = ((thetaDegrees - oldAngleDegrees + 180 + 360) % 360) - 180;
//let angleDelta = thetaDegrees - oldAngleDegrees;
            d.x = newXY.x;
            d.y = newXY.y;

            d.degNew = angleDelta + d.currentDeg;
            d.currentDeg = d.degNew;
            //console.log("degnew, currentdeg, CDD, angledelta", d.degNew, d.currentDeg, currentDialDeg, angleDelta);
            currentDialDeg = clamp(angleDelta + currentDialDeg, startDegree, endDegree);
            //console.log(currentDialDeg);

            updateDialText(currentDialDeg, callback);
        })
        .on("end", (event, d) => {
            d.currentDeg = d.degNew;
        });


    dialGroup = svg.append("g")
        .data([{x: 0, scale: d3.scaleLinear().domain([0, width]).range([startDegree, endDegree])}]) // initial data for dialGroup
        .attr("transform", `translate(${dialX}, ${dialY}) rotate(${startPos})`)
        .call(drag);

    // Add a transparent circle for better dragging
    dialGroup.append("circle")
        .attr("r", radius)
        .style("fill", "transparent");

    dialGroup.append("circle")
        .attr("r", radius)
        .style("fill", "none")
        .style("stroke", DIAL_OUTLINE_COLOR)
        .style("stroke-width", `${strokeWidth}px`);

    dialGroup.append("line")
        .attr("x1", 0)
        .attr("y1", 0)
        .attr("x2", 0)
        .attr("y2", -(radius - strokeWidth))
        .style("stroke", DIAL_STICK_COLOR/*FAB_PALETTE[6]*/)
        .style("stroke-width", `${strokeWidth}px`)
        .style("stroke-linecap", "round");

    // Display the initial mapped value
    var initialScale = d3.scaleLinear().domain([startDegree, endDegree]).range([mapMin, mapMax]);
    var initialMappedValue = initialScale(startPos);
}

Array.prototype.search = function(elem) {
    for(var i = 0; i < this.length; i++) {
        if(this[i] == elem) return i;
    }
    
    return -1;
  };
  
  var Multiselect = function(selector, callback) {
    if(!$(selector)) {
        console.error("ERROR: Element %s does not exist.", selector);
        return;
    }
  
    this.selector = selector;
    this.selections = [];
    this.callback = callback;
  
    (function(that) {
        that.events(callback);
    })(this);
  };
  
  Multiselect.prototype = {
    open: function(that) {
        var target = $(that).parent().attr("data-target");
  
        // If we are not keeping track of this one's entries, then start doing so.
        if(!this.selections) {
            this.selections = [ ];
        }
  
        $(this.selector + ".multiselect").toggleClass("active");
    },
  
    close: function() {
        $(this.selector + ".multiselect").removeClass("active");
    },
    
    events: function(callback) {  // Pass the callback function as an argument
      var that = this;
    
      $(document).on("click", that.selector + ".multiselect > .title", function(e) {
          if(e.target.className.indexOf("close-icon") < 0) {
              that.open();
          }
      });
    
      $(document).on("click", that.selector + ".multiselect > .title > .close-icon", function(e) {
          that.clearSelections();
      });
  
      
      $(document).on("click", that.selector + ".multiselect option", function(e) {
      var selection = $(this).attr("value");
      var optionsCount = $(that.selector + ".multiselect option").length ;//- 1;  // -1 for 'All' option
      console.log(selection);
      if (selection == "All") {
          if (that.selections.search("All") < 0) {
          // Select All
          that.selections = $(that.selector + ".multiselect option").map(function() { return $(this).val(); }).get();
          } else {
          // Deselect All
          that.selections = [];
          }
      } else {
          var io = that.selections.search(selection);
          console.log("IO", io);
          if(io < 0) that.selections.push(selection);
          else that.selections.splice(io, 1);
          console.log(optionsCount, that.selections.length, that.selections)
          // If not all options are selected, deselect "All"
          if (that.selections.length !== optionsCount && that.selections.search("All") >= 0) {
          const res = that.selections.search("All");
          if (res != -1) that.selections.splice(res, 1);
          }
          // If all options are selected, also select 'All'
          else if (that.selections.length === optionsCount - 1 && that.selections.search("All") < 0) {
          console.log("adding all");
          that.selections.push('All');
          }
          console.log("NEW", that.selections.length, optionsCount - 1, that.selections.search("All"));
      }
  
      that.selectionStatus();
      that.setSelectionsString();
      if (typeof callback === "function") { 
          callback(that.selections);
      }
      });
    },
  
    selectionStatus: function() {
        var obj = $(this.selector + ".multiselect");
  
        if(this.selections.length) obj.addClass("selection");
        else obj.removeClass("selection");
    },
  
    clearSelections: function() {
        this.selections = [];
        this.selectionStatus();
        this.setSelectionsString();
        this.callback([]);
    },
  
    getSelections: function() {
        return this.selections;
    },
  
    setSelectionsString: function() {
        var selects = this.getSelectionsString().split(", ");
        $(this.selector + ".multiselect > .title").attr("title", selects);
  
        var opts = $(this.selector + ".multiselect option");
  
        if(selects.toString().length > 16) {
          $(this.selector + ".multiselect > .title > .text")
              .text(selects.toString().slice(0,16) + "...");
        }
        else {
            $(this.selector + ".multiselect > .title > .text")
                .text(selects);
        }
  
        for(var i = 0; i < opts.length; i++) {
            $(opts[i]).removeClass("selected");
        }
        console.log(selects);
        for(var j = 0; j < selects.length; j++) {
            var select = selects[j];
            for(var i = 0; i < opts.length; i++) {
                if($(opts[i]).attr("value") == select || select == "All") {
                    $(opts[i]).addClass("selected");
                    if (select != "All") break;
                }
            }
        }
    },
  
    getSelectionsString: function() {
        // If "All" is selected, return "All"
      if(this.selections.search("All") >= 0)
          return "All";
      else if(this.selections.length > 0)
          return this.selections.join(", ");
      else return "Filter Labs";
    },
  
    setSelections: function(arr) {
        if(!arr[0]) {
            error("ERROR: This does not look like an array.");
            return;
        }
  
        this.selections = arr;
        this.selectionStatus();
        this.setSelectionsString();
    },
  };
  
  const initializeLabMultiselect = (labs, callback) => {
    $(document).ready(function() {
      var multi = new Multiselect("#countries", callback);
    });
  
    const select = d3.select("#my_dataviz").select("div div.container");
  
    select.selectAll("option")
      .data(["All"].concat(labs))  // Add "All" option to the start of the list
      .join("option")
      .attr("value", d => d)
      .html(d => d);
  };

  const createOverlayText = () => {
    createdBy();
};

const createdBy = () => {
    const xPos = 10; // 10px from the left edge
    
    const createTxt = (ySub, txt, lnk_txt, lnk) => {
        const yPos = height - ySub; // 10px from the bottom edge
        svg.append("text")
            .attr("font-size", "14px")
            .attr("x", xPos)
            .attr("y", yPos)
            .attr("class", "overlay-text")
            .text(txt + " ")
            .append("a")
            .attr("xlink:href", lnk)
            .attr("target", "_blank") 
            .style("fill", OVERLAY_TEXT_LINK_COLOR)
            .attr("font-size", "14px")
            .text(lnk_txt);
    };

    createTxt(50, "Created by", "Adam Stone", "https://fabacademy.org/2023/labs/charlotte/students/adam-stone/")
    createTxt(35, "For documentation", "click here", "https://gitlab.fabcloud.org/pub/project/expert-network-map/-/blob/b15d89d91454904d523efbfc174db7638cc8f462/documentation.md")
    createTxt(20, "Took inspiration from", "Nadieh Bremer", "https://royalconstellations.visualcinnamon.com/")
    createTxt(5, "Recieved guidance and support from", "Francisco Sanchez", "https://www.fablabs.io/users/francisco")
};


//(async function(){
  /*await */
  window.onload = () => {
    Tooltip = d3.select("#tooltip");
    body = document.getElementsByTagName('body')[0];
   
  create_not_filteredFromJSON().then(()=>{
    calculateMinMaxMapFromFiltered();
  createReferenceCache();
  
  createNumLinksDictFrom_not_filtered(nodes_not_filtered, links_not_filtered);
  setLabs(nodes_not_filtered.map(n=>n.id));
  
  transferNot_filteredToArrays();
  
  calculateMaxStrength();
  
  setCurrentLabHighlightList();
  createSimulation();
  createAndFormatSVG();
  initializeDefs();
  gl_ = svg.append("g").attr("transform", "translate(150, -10)");
  //link = linksToLink(true);
  
  registerLinearGradients(links_not_filtered); // so that when they are needed all of the gradients are available; this could only use links that ever would need to have a linear gradient to improve performance
  nodesToNodeAndFormat();
  /*node = configureNode(node, nodes);
  calibrateSimulation();
  node = setNodeTooltips(node);    
  setSimulationTick(node,link);    
  configureGlowDefinitions();*/
  createPie();

  createOverlayText();

  

  updateData({
    minNumConnections: 20,
      simulation,
      svg,
      g,
      "gl": gl_
  })

  initializeCarousel(d => {
    //selectByTopic(d);
    
    currentTopic = d;
    if (currentTopic != "All") {
      mapMin = minMaxMap[currentTopic].min;
      mapMax = minMaxMap[currentTopic].max /*+ 1*/;
    }
    else {
      [mapMin, mapMax] = [1, 60];
    }
    /*updateData({
      minNumConnections,
      simulation,
      svg,
      g,
      "isFirst": false
    });*/
    
    updateDialText(currentDialDeg, dialCallback); // calls updateData
    //dialCallback(minNumConnections);//dialCallback(minNumConnections);
  }, topicCarouselList, 350, 600, 30, 10, svg, FAB_PALETTE);

  const labCallback = lab_list => {
    currentLabHighlightList = lab_list;
    updateData({
      minNumConnections,
      simulation,
      svg,
      g,
      "gl": gl_
    });
    /*currentLabHighlightList = lab_list;
    node.attr("opacity", data => {
      const lab = data.id.split(";")[1].split("/")[5];
      const y = data.id.split(";")[1].split("/")[3];
      if (lab_list.includes(lab) && (y == currentYear || currentYear == "All")) {
        return NODE_HIGHLIGHTED_OPACITY;
      }
      else {
        return minOpacity;
      }
    });
    setLinkOpacity();*/
  };

  const dialCallback = (roundedVal, first=false) => {
    //if (minNumConnections == roundedVal && !first) return; // CAUSES ISSUES WEHN CALLED FROM OTHER PLACES
    minNumConnections = roundedVal;
    updateData({
      "minNumConnections": roundedVal,
      simulation,
      svg,
      g,
      "gl": gl_,
      "isFirst": first
    });
    /*transferNot_filteredToArrays();
    
    calculateMaxStrength();

    link = linksToLink(false);

    let nodeNewData = configureNode(node, nodes);
    
    node = nodeNewData;
    
    //simulation.nodes(nodes);
    //forceCollide.initialize(nodes);
    //simulation.force("link").links(links);
    //calibrateSimulation();
    //setSimulationTick(node, link);

    setNodeTooltips(node);
    
    //simulation.alpha(1).restart();    
    
    selectByTopic(currentTopic);
    setYear(currentYear);
    labCallback(currentLabHighlightList);*/
  };

  //dialCallback(20, first=true);

  initializeDial(svg, dialCallback);

  initializeLabMultiselect(labs, labCallback);

});
//})();
  };